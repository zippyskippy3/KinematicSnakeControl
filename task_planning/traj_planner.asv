% function X_DES = traj_planner(t, x)
% 
% % body angle desired
% 
% alpha = pi / 6;
% delta = 36 * pi / 180;
% eta = 70 * pi * t / 180;
% deta = 70 * pi / 180;
% 
% q_des = zeros(7, 1);
% dq_des = zeros(7, 1);
% 
% for i = 1:7
%     q_des(i) = alpha * sin(eta + (i-1)*delta) + phi_0;
%     dq_des(i) = -alpha * cos(eta + (i-1)*delta) * deta;
%     ddq_des(i) = -alpha * sin(eta + (i-1)*delta) * deta^2;
% end
% 
% % head angle desired
% 
% % design parameter look ahead distance
% LAD = 1.4;
% 
% py = x(10);
% 
% % aligned with the x axis as the goal path
% py_des = 0;
% 
% theta_des = -atan(py_des - py / LAD);
% 
% X_DES = [q_des theta_des; dq_des dtheta_des];
% 
% 
% end

function X_DES = traj_planner(t, x_full)
    % traj_planner Calculates VHC references for a snake robot
    % Output X_DES = [Phi_des; dPhi_des; ddPhi_des] (24x1 vector)

    % --- Path Definition ---
    py_des = 0;      % Desired lateral position (Straight line on X)
    dpy_des = 0;     % Velocity of path
    d2py_des = 0;    % Acceleration of path
    
    % --- Constants ---
    N_JOINTS = 7;
    N_AUGMENTED = 12;
    
    alpha = pi / 4;             
    delta = 1;      
    deta = 0.5;       % Phase velocity
    LAD = 1.4;                  % Look Ahead Distance
    
    % --- State Extraction ---
    % Mapping: [q_a(7); theta; px; py; eta; phi_0]
    py = x_full(10);            
    dpy = x_full(10 + N_AUGMENTED); % Velocity index 22
    
    phi_0 = x_full(12);         
    dphi_0 = x_full(12 + N_AUGMENTED); 
    d2phi_0 = 0; % Feedforward assumption
    
    eta = deta * t; % Constant phase progression
    
    % Initialize Vectors
    Phi_des = zeros(8, 1);
    dPhi_des = zeros(8, 1);
    ddPhi_des = zeros(8, 1); 

    % --- 1. Joint VHCs (Serpenoid Curve) ---
    for i = 1:N_JOINTS
        offset = (i-1) * delta;
        
        % Sinusoid derivatives
        S_i = alpha * sin(eta + offset);
        dS_i = alpha * cos(eta + offset) * deta;
        d2S_i = -alpha * sin(eta + offset) * deta^2;
        
        % Constraint: q_i = S_i + phi_0
        Phi_des(i) = S_i + phi_0;
        dPhi_des(i) = dS_i + dphi_0;        
        ddPhi_des(i) = d2S_i + d2phi_0;     
    end
    
    % --- 2. Head Angle VHC (Steering) ---
    % Steering Law: Point head towards path
    py_error = py_des - py;
    theta_des = -atan(py_error / LAD);
    
    % 1st Derivative (Chain Rule)
    % d/dt(-atan(u)) = -1/(1+u^2) * du/dt
    u_val = py_error / LAD;
    du_dt = (dpy_des - dpy) / LAD; 
    dtheta_des = - (1 / (1 + u_val^2)) * du_dt;
    
    % 2nd Derivative (Simplified for stability)
    d2theta_des = 0; 
    
    % Assign Head Constraints (Index 8)
    Phi_des(8) = theta_des;
    dPhi_des(8) = dtheta_des;
    ddPhi_des(8) = d2theta_des; 
    
    % --- Output Construction ---
    X_DES = [Phi_des; dPhi_des; ddPhi_des];
end